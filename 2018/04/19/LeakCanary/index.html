<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>LeakCanary源码浅析 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在Android开发中最让人们头疼的就是内存泄漏了，今天来介绍一个查看内存是否泄漏的工具LeakCanary，并通过研究源码明白它是如何分析和查找存在泄漏信息的首先送上LeakCanary文档链接:LeakCanary中文使用说明 Part1. 知识回顾常用工具  Mat    LeakCanary(Square）原理:watch监视一个即将要销毁的对象    内存种类 1、栈（stack-基本数">
<meta property="og:type" content="article">
<meta property="og:title" content="LeakCanary源码浅析">
<meta property="og:url" content="http://yoursite.com/2018/04/19/LeakCanary/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="在Android开发中最让人们头疼的就是内存泄漏了，今天来介绍一个查看内存是否泄漏的工具LeakCanary，并通过研究源码明白它是如何分析和查找存在泄漏信息的首先送上LeakCanary文档链接:LeakCanary中文使用说明 Part1. 知识回顾常用工具  Mat    LeakCanary(Square）原理:watch监视一个即将要销毁的对象    内存种类 1、栈（stack-基本数">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-04-19T03:48:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeakCanary源码浅析">
<meta name="twitter:description" content="在Android开发中最让人们头疼的就是内存泄漏了，今天来介绍一个查看内存是否泄漏的工具LeakCanary，并通过研究源码明白它是如何分析和查找存在泄漏信息的首先送上LeakCanary文档链接:LeakCanary中文使用说明 Part1. 知识回顾常用工具  Mat    LeakCanary(Square）原理:watch监视一个即将要销毁的对象    内存种类 1、栈（stack-基本数">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-LeakCanary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/19/LeakCanary/" class="article-date">
  <time datetime="2018-04-19T03:28:18.000Z" itemprop="datePublished">2018-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeakCanary源码浅析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Android开发中最让人们头疼的就是内存泄漏了，今天来介绍一个查看内存是否泄漏的工具LeakCanary，并通过研究源码明白它是如何分析和查找存在泄漏信息的<br>首先送上LeakCanary文档链接:<a href="https://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="noopener">LeakCanary中文使用说明</a></p>
<h2 id="Part1-知识回顾"><a href="#Part1-知识回顾" class="headerlink" title="Part1. 知识回顾"></a>Part1. 知识回顾</h2><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><ul>
<li><ol>
<li>Mat</li>
</ol>
</li>
<li><ol start="2">
<li>LeakCanary(Square）<br>原理:watch监视一个即将要销毁的对象</li>
</ol>
</li>
</ul>
<h3 id="内存种类"><a href="#内存种类" class="headerlink" title="内存种类"></a>内存种类</h3><ul>
<li>1、栈（stack-基本数据类型，对象的引用）</li>
<li>2、堆（heap-存放new出来的对象和数组，在堆中分配内存由GC管理）</li>
<li>3、方法区（method,大体和堆一样）</li>
</ul>
<h3 id="为什么会产生内存泄漏"><a href="#为什么会产生内存泄漏" class="headerlink" title="为什么会产生内存泄漏"></a>为什么会产生内存泄漏</h3><ul>
<li>当一个对象已经不需要再使用了，在该对象被回收时候，有另外的对象引用该回收对象，导致本该被回收的对象无法回收</li>
<li>有些对象只有有限的生命周期，当生命周期很短的完成任务后，在本该结束的生命周期中仍然被引用</li>
</ul>
<h3 id="内存泄漏会导致什么问题"><a href="#内存泄漏会导致什么问题" class="headerlink" title="内存泄漏会导致什么问题"></a>内存泄漏会导致什么问题</h3><ol>
<li>OOM</li>
</ol>
<h3 id="常见的内存泄漏情况"><a href="#常见的内存泄漏情况" class="headerlink" title="常见的内存泄漏情况"></a>常见的内存泄漏情况</h3><ol>
<li>单例造成的内存泄漏</li>
<li>非静态内部类创建静态实例造成的内存泄漏</li>
<li>handler造成内存泄漏（handler、message、MessageQueue）<br>解决方法：<pre><code>①将Handler声明为静态类型    
②通过弱引用的方式引入Activity
</code></pre></li>
<li>线程造成的内存泄漏（解决方法:将线程定义声明为static类型）</li>
<li>webview造成的内存泄漏（example：加载页面很复杂，Ex:大量的图片）  </li>
</ol>
<h2 id="Part2-概念"><a href="#Part2-概念" class="headerlink" title="Part2 概念"></a>Part2 概念</h2><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ol>
<li>强引用（StrongReference），默认对象一般为强引用</li>
<li>软引用（SoftReference），当内存空间足够大时相当于强引用，内存不够时通过垃圾回收器（GC）自动回收</li>
<li>弱引用（WeakReference），当GC扫描到该类型的引用时就自己回收</li>
<li>虚引用，相当于没有进行引用，GC可随时回收该类型的引用</li>
</ol>
<h3 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h3><ol>
<li>软引用和弱引用都持有该对象</li>
<li>对象被垃圾回收，Java虚拟机就会把这个引用加入到与之相关联的引用队列中 </li>
</ol>
<h2 id="Part3-LeakCanary使用"><a href="#Part3-LeakCanary使用" class="headerlink" title="Part3.LeakCanary使用"></a>Part3.LeakCanary使用</h2><ol>
<li>在module层级中的build.gradle中加入引用，不同的编译使用不同的引用   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    debugCompile <span class="string">'com.squareup.leakcanary:leakcanary-android:1.3'</span></span><br><span class="line">    releaseCompile <span class="string">'com.squareup.leakcanary:leakcanary-android-no-op:1.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.在Application中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.在Manifest.xml中加载该Application文件   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;application android:name=<span class="string">".MyApplication"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>#Part4. LeakCanary源码剖析</p>
<p>从代码入口剖析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LeakCanary.install(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>跟踪源码可知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a &#123;<span class="doctag">@link</span> RefWatcher&#125; that works out of the box, and starts watching activity</span></span><br><span class="line"><span class="comment">   * references (on ICS+).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">install</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> install(application, DisplayLeakService.class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们发现这个方法最终返回给我们一个RefWatcher这个类，这个类是主要是启动ActivityRefWatcher类，ActivityRefWatcher在Activity的onDestory方法结束时检测内存泄漏。</p>
<p>看下install这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a &#123;<span class="doctag">@link</span> RefWatcher&#125; that reports results to the provided service, and starts watching</span></span><br><span class="line"><span class="comment">   * activity references (on ICS+).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">install</span><span class="params">(Application application,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInAnalyzerProcess(application)) &#123;</span><br><span class="line">      <span class="keyword">return</span> RefWatcher.DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line">    enableDisplayLeakActivity(application);</span><br><span class="line">    HeapDump.Listener heapDumpListener =</span><br><span class="line">        <span class="keyword">new</span> ServiceHeapDumpListener(application, listenerServiceClass);</span><br><span class="line">    RefWatcher refWatcher = androidWatcher(application, heapDumpListener);</span><br><span class="line">    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</span><br><span class="line">    <span class="keyword">return</span> refWatcher;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>RefWatcher refWatcher = androidWatcher(application, heapDumpListener)</code>创建一个RefWatcher对象，启动activityRefWatcher来监视内存泄漏<br><code>enableDisplayLeakActivity(application)</code>主要作用是开启DisplayLeakActivity这个类，这个类主要是显示内存泄漏的弹框页面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installOnIcsPlus</span><span class="params">(Application application, RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &lt; ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">      <span class="comment">// If you need to support Android &lt; ICS, override onDestroy() in your base activity.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityRefWatcher activityRefWatcher = <span class="keyword">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class="line">    activityRefWatcher.watchActivities();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchActivities</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure you don't get installed twice.</span></span><br><span class="line">    stopWatchingActivities();</span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopWatchingActivities</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>小结：<br>①通过stopWatcher方法反注册以前的Activity的生命周期的callback，目的是为了保证以前的内存泄漏的activity删除<br>②重新注册activity生命周期的callback<br>③通过lifecycleCallbacks中的onActivityDestroyed方法将activity的生命周期和ActivityReference关联起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    ActivityRefWatcher.<span class="keyword">this</span>.onActivityDestroyed(activity);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>跟踪onActivityDestroyed方法发现通过调用RefWatcher调用了watcher类<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void onActivityDestroyed(Activity activity) &#123;</span><br><span class="line">    refWatcher.watch(activity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final RefWatcher refWatcher</span><br></pre></td></tr></table></figure>
<p>  下面我们进入RefWatcher类中发现有如下的变量信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor watchExecutor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DebuggerControl debuggerControl;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GcTrigger gcTrigger;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HeapDumper heapDumper;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; retainedKeys;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HeapDump.Listener heapdumpListener;</span><br></pre></td></tr></table></figure>
<p>  上述变量大意如下:</p>
<ol>
<li>watchExecutor主要用于执行内存泄漏检测</li>
<li>debuggerControl查询我们是否正在调试中，如果我们正在调试过程中则不会进行判断</li>
<li>gcTrigger用于处理GC，用于在判断泄漏对象之前再调用GC类中的方法再次判断</li>
<li>heapDumper用于dump中内存泄漏堆文件</li>
<li>retainedKeys该set集合持有待检测和已产生内存泄漏信息的key</li>
<li>queue引用对象，主要是判断弱引用所持有的对象是否已执行GC垃圾收回</li>
<li><p>heapdumpListener主要用于分析产生hprof文件回调</p>
<p>查看watch方法可知:</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Watches the provided references and checks if it can be GCed. This method is non blocking,</span></span><br><span class="line"><span class="comment"> * the check is done on the &#123;<span class="doctag">@link</span> Executor&#125; this &#123;<span class="doctag">@link</span> RefWatcher&#125; has been constructed with.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> referenceName An logical identifier for the watched object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class="line">  checkNotNull(watchedReference, <span class="string">"watchedReference"</span>);</span><br><span class="line">  checkNotNull(referenceName, <span class="string">"referenceName"</span>);</span><br><span class="line">  <span class="keyword">if</span> (debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime = System.nanoTime();</span><br><span class="line">  String key = UUID.randomUUID().toString();</span><br><span class="line">  retainedKeys.add(key);</span><br><span class="line">  <span class="keyword">final</span> KeyedWeakReference reference =</span><br><span class="line">      <span class="keyword">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class="line">  watchExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ensureGone(reference, watchStartNanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过产生一个唯一的key添加到retainedKeys<set>集合中</set></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String key = UUID.randomUUID().toString();</span><br><span class="line">retainedKeys.add(key);</span><br></pre></td></tr></table></figure>
<p>   再创建一个KeyedWeakReference的弱引用，并开启一个异步线程来分析创建好的弱引用，该线程主要作用是确保我们的Activity是否真正已经进入到GONE状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureGone</span><span class="params">(KeyedWeakReference reference, <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> gcStartNanoTime = System.nanoTime(); </span><br><span class="line">    <span class="comment">//计算过去的方法到调用GC垃圾收回的时间值</span></span><br><span class="line">    <span class="keyword">long</span> watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</span><br><span class="line">    <span class="comment">//清除已经到达我们引用队列的弱引用</span></span><br><span class="line">    removeWeaklyReachableReferences();</span><br><span class="line">    <span class="comment">//判断如果处于debug状态就不再进行内存分析</span></span><br><span class="line">    <span class="keyword">if</span> (gone(reference) || debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gcTrigger.runGc();<span class="comment">//手动进行垃圾回收</span></span><br><span class="line">    removeWeaklyReachableReferences();</span><br><span class="line">    <span class="keyword">if</span> (!gone(reference)) &#123;</span><br><span class="line">      <span class="keyword">long</span> startDumpHeap = System.nanoTime();</span><br><span class="line">      <span class="keyword">long</span> gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line">      File heapDumpFile = heapDumper.dumpHeap();<span class="comment">//dump出内存泄漏的文件</span></span><br><span class="line">      <span class="keyword">if</span> (heapDumpFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Could not dump the heap, abort.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line">      <span class="comment">//开始分析内存泄漏文件查找内存泄漏路径</span></span><br><span class="line">      heapdumpListener.analyze(</span><br><span class="line">          <span class="keyword">new</span> HeapDump(heapDumpFile, reference.key, reference.name, watchDurationMs, gcDurationMs,</span><br><span class="line">              heapDumpDurationMs));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>  以上代码部分总结如下:</p>
<ol>
<li>首先创建一个RefWatcher，启动一个ActivityRefWatcher</li>
<li>通过ActivityLifecyclecallback将Activity的onDestroy生命周期给关联起来</li>
<li>最后通过执行execute线程来分析泄漏信息</li>
</ol>
<h3 id="探讨LeakCanary中Activity泄漏检测机制代码"><a href="#探讨LeakCanary中Activity泄漏检测机制代码" class="headerlink" title="探讨LeakCanary中Activity泄漏检测机制代码"></a>探讨LeakCanary中Activity泄漏检测机制代码</h3><p>在上面的ensureGone方法中最后我们发现有这样的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heapdumpListener.analyze(</span><br><span class="line">          <span class="keyword">new</span> HeapDump(heapDumpFile, reference.key, reference.name, watchDurationMs, gcDurationMs,</span><br><span class="line">              heapDumpDurationMs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过跟踪发现analyze方法该方法是<code>HeapDump</code>类中的一个interface接口，再查看它的实现类发现在<code>ServiceHeapDumpListener</code>这个类中的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyze</span><span class="params">(HeapDump heapDump)</span> </span>&#123;</span><br><span class="line">    checkNotNull(heapDump, <span class="string">"heapDump"</span>);</span><br><span class="line">    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);</span><br><span class="line">  &#125;</span><br><span class="line">``` </span><br><span class="line">  继续跟踪`runAnalysis`方法发现在`HeapAnalyzerService`中，且该类继承了`intentService`，因此它将会每次调用`onHandleIntent`方法</span><br><span class="line">``` java </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);</span><br><span class="line">    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</span><br><span class="line">    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);</span><br><span class="line">    AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);</span><br><span class="line">  &#125;</span><br><span class="line">通过checkForLeak方法来分析内存泄漏信息的结果，并通过sendResultToListener显示最终的结果</span><br><span class="line"><span class="function"><span class="keyword">public</span> AnalysisResult <span class="title">checkForLeak</span><span class="params">(File heapDumpFile, String referenceKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> analysisStartNanoTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (!heapDumpFile.exists()) &#123;</span><br><span class="line">      Exception exception = <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File does not exist: "</span> + heapDumpFile);</span><br><span class="line">      <span class="keyword">return</span> failure(exception, since(analysisStartNanoTime));</span><br><span class="line">    &#125;</span><br><span class="line">    ISnapshot snapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      snapshot = openSnapshot(heapDumpFile);<span class="comment">//生成内存快照信息</span></span><br><span class="line">      IObject leakingRef = findLeakingReference(referenceKey, snapshot);<span class="comment">//查看内存的引用</span></span><br><span class="line">      <span class="comment">// False alarm, weak reference was cleared in between key check and heap dump.</span></span><br><span class="line">      <span class="keyword">if</span> (leakingRef == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> noLeak(since(analysisStartNanoTime));</span><br><span class="line">      &#125;</span><br><span class="line">      String className = leakingRef.getClazz().getName();</span><br><span class="line">      AnalysisResult result =</span><br><span class="line">          findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">if</span> (!result.leakFound) &#123;</span><br><span class="line">        result = findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, <span class="keyword">false</span>);<span class="comment">//寻找内存泄漏的路径</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SnapshotException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> failure(e, since(analysisStartNanoTime));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      cleanup(heapDumpFile, snapshot);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>  总结checkForLeak方法<br>  1.把.hprof转为 Snapshot<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snapshot = openSnapshot(heapDumpFile);</span><br></pre></td></tr></table></figure></p>
<p>  2.找出泄漏的对象/泄漏对象的最短路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IObject leakingRef = findLeakingReference(referenceKey, snapshot);</span><br><span class="line">AnalysisResult result =</span><br><span class="line">findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, className, true);</span><br></pre></td></tr></table></figure></p>
<p>findLeakingReference作用<br>          ①在snapshot快照中找到第一个弱引用即为内存发生泄漏的引用<br>          ②遍历这个对象的所有实例信息<br>          ③如果发现存在key值与之前定义封装好的key值相同，那么返回这个定位到的泄漏对象<br>findLeakTrace是通过获取内存泄漏的引用来获取泄漏路径的最短路径          </p>
<h3 id="了解LeakCanary的原理"><a href="#了解LeakCanary的原理" class="headerlink" title="了解LeakCanary的原理"></a>了解LeakCanary的原理</h3><ol>
<li>Activity Destroy（）之后将它放在一个WeakReference中</li>
<li>将WeakReference关联到一个ReferenceQueue</li>
<li>查看ReferenceQueue是否存有Activity的引用</li>
<li>如果该Activity泄露了，Dump出heap信息，然后去分析泄漏路径</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/19/LeakCanary/" data-id="cjg5zldgo0000xd3d619r9ruu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/04/19/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/19/LeakCanary/">LeakCanary源码浅析</a>
          </li>
        
          <li>
            <a href="/2018/04/19/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>